"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = exports.parseArguments = exports.parse = void 0;
var child_process_1 = __importDefault(require("child_process"));
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var dotenv_1 = __importDefault(require("dotenv"));
var dotenv_expand_1 = __importDefault(require("dotenv-expand"));
var DEFAULT_DOT_ENV = path_1.default.resolve(".env");
function parse(content, env, readonlyKeys, debug) {
    if (debug === void 0) { debug = false; }
    var parsed = dotenv_1.default.parse(content, { debug: debug });
    var combined = __assign({}, env);
    for (var key in parsed) {
        if (!readonlyKeys.has(key)) {
            combined[key] = parsed[key];
        }
    }
    // Expand the dotenv (updates to process.env as a side-effect)
    dotenv_expand_1.default({ parsed: combined, ignoreProcessEnv: true });
    return combined;
}
exports.parse = parse;
function parseArguments(args) {
    var dotEnvPaths = [];
    for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
        var arg = args_1[_i];
        if (arg === "--") {
            break;
        }
        else if (fs_1.default.existsSync(arg) && fs_1.default.statSync(arg).isFile()) {
            var dotEnvPath = path_1.default.resolve(arg);
            dotEnvPaths.push(dotEnvPath);
        }
        else {
            break;
        }
    }
    if (dotEnvPaths.length > 0) {
        return {
            dotEnvPaths: dotEnvPaths,
            rest: args.slice(dotEnvPaths.length),
        };
    }
    else if (fs_1.default.existsSync(DEFAULT_DOT_ENV) && fs_1.default.statSync(DEFAULT_DOT_ENV).isFile()) {
        return {
            dotEnvPaths: [DEFAULT_DOT_ENV],
            rest: args,
        };
    }
    else {
        throw new Error("Failed to load a .env file");
    }
}
exports.parseArguments = parseArguments;
/**
 * Run a script from the package.json (read relative to CWD).
 * @returns Status code from the child process.
 */
function run(argv, encoding) {
    if (encoding === void 0) { encoding = "utf8"; }
    var args = argv.slice(2);
    // Start with a copy of the current process environment
    var readonlyKeys = new Set(Object.keys(process.env));
    var env = __assign({}, process.env);
    // Parse the arguments getting to the .dot files
    var parsedArgs = parseArguments(args);
    // Parse dotenv file (updating the combined env)
    for (var _i = 0, _a = parsedArgs.dotEnvPaths; _i < _a.length; _i++) {
        var dotEnvPath = _a[_i];
        var content = fs_1.default.readFileSync(dotEnvPath, { encoding: encoding });
        env = parse(content, env, readonlyKeys);
    }
    // Execute the "npm run-script" command, which forks with the updated process.env
    return child_process_1.default.spawnSync("npm", __spreadArrays(["run-script"], parsedArgs.rest), { stdio: "inherit", env: env }).status;
}
exports.run = run;
